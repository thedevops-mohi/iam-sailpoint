{
    "version": 1,
    "timestamp": "2025-08-13T01:56:27.192470Z",
    "tenant": "igmfinancial-uat",
    "description": "Exporting RULE",
    "options": {
        "excludeTypes": [],
        "includeTypes": [
            "RULE"
        ],
        "objectOptions": {}
    },
    "objects": [
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "090f245ec14e46ad8d1762f3acecd252",
                "name": "Employee and Contractor - Manager Correlation TWF"
            },
            "object": {
                "description": "Employee and Contractor Manager Correlation.",
                "type": "ManagerCorrelation",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2025-04-22 04:18:40",
                    "script": "\n\nimport sailpoint.object.Identity;\n\timport sailpoint.object.Link;\n\timport java.util.List;\n\timport java.util.Map;\n\timport java.util.HashMap;\n\timport sailpoint.api.SailPointContext;\n\timport sailpoint.server.IdnRuleUtil;\n\timport sailpoint.rule.Identity;\n\t\n\tMap returnMap = new HashMap();\n\tString finalManager = null;\n\tboolean userHasSAP = false;\n\tString sapEccManager = null, serviceNowManager = null, SFNonAuthManager = null, SFAuthManager = null;\n\t\n\tsailpoint.object.Identity identity =  link.getIdentity();\n\tString userType = identity.getAttribute(\"userType\");\n\tString userLCS = identity.getAttribute(\"cloudLifecycleState\");\n\tString bestSource = identity.getAttribute(\"sourceoftruth\");\n\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", userType: \" +userType+ \",userLCS: \" +userLCS);\n\t\n\tList userLinks = identity.getLinks();\n\tfor(Link link: userLinks){\n\t\tif(link.getApplicationName().equals(\"Employees SAP ECC [source]\")){\n\t\t\tuserHasSAP = true;\n\t\t\tsapEccManager = link.getAttribute(\"MANAGER\");\n\t\t}\n\t\tif(link.getApplicationName().equals(\"ServiceNowAPI [source]\")){\n\t\t\tserviceNowManager = link.getAttribute(\"manager\");\n\t\t}\n\t\tif(link.getApplicationName().equals(\"SuccessFactors - Authoritative [source]\")){\n\t\t\tSFAuthManager = link.getAttribute(\"ManagerID\");\n\t\t}\n\t\tif(link.getApplicationName().equals(\"SuccessFactors - NonAuthoritative [source]\")){\n\t\t\tSFNonAuthManager = link.getAttribute(\"ManagerID\");\n\t\t}\n\t}\n\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", userHasSAP: \" +userHasSAP+ \", sapEccManager: \" +sapEccManager+ \", serviceNowManager: \"+serviceNowManager);\n\t\n\tif(userHasSAP && \"use_SAPECC\".equalsIgnoreCase(bestSource) && \"Employee\".equalsIgnoreCase(userType)){\n\t\t//If SAP ECC account exists, get manager from SAP ECC account\n\t\treturnMap.put(\"identityAttributeName\", \"employeeId\");\n\t\treturnMap.put(\"identityAttributeValue\", sapEccManager);\n\t}\n\telse if(\"use_SFNonAuth\".equalsIgnoreCase(bestSource)){\n\t    returnMap.put(\"identityAttributeName\", \"personid\");\n\t\treturnMap.put(\"identityAttributeValue\", SFAuthManager);\n\t}\n\telse if(\"use_SFAuth\".equalsIgnoreCase(bestSource)){\n\t returnMap.put(\"identityAttributeName\", \"personid\");\n\treturnMap.put(\"identityAttributeValue\", SFNonAuthManager);\n\t}\n\telse {\n\t\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", user has no SAP ECC acct or Contractor\");\n\t\tif(null != serviceNowManager && \"Contractor\".equalsIgnoreCase(userType)){\n\t\t\tList managers = idn.findIdentitiesBySearchableIdentityAttribute(\"samaccountname\", \"Equals\", serviceNowManager, \"samaccountname\");\n\t\t\t\n\t\t\tif(null != managers && !managers.isEmpty() && (\"prehire\".equalsIgnoreCase(userLCS) || \"active\".equalsIgnoreCase(userLCS) || \"suspended\".equalsIgnoreCase(userLCS))){\n\t\t\t\tfor (sailpoint.rule.Identity manager : managers) {\n\t\t\t\t\tMap managerAttributes = manager.getAttributes();\n\t\t\t\t\tString managerLCS = (String) managerAttributes.get(\"cloudLifecycleState\");\n\t\t\t\t\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", managerLCS: \"+managerLCS);\n\t\t\t\t\t\n\t\t\t\t\tif(\"active\".equalsIgnoreCase(managerLCS)){\n\t\t\t\t\t\tfinalManager = serviceNowManager;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString superManagerId = manager.getManagerId();\n\t\t\t\t\t\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", superManagerId: \"+superManagerId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tsailpoint.rule.Identity superManagerIdentity = idn.getIdentityById(superManagerId);\n\t\t\t\t\t\tif(superManagerIdentity != null){\n\t\t\t\t\t\t\tMap supermanAttributes = superManagerIdentity.getAttributes();\n\t\t\t\t\t\t\tfinalManager = (String) supermanAttributes.get(\"samaccountname\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfinalManager = serviceNowManager;\n\t\t}\n        returnMap.put(\"identityAttributeName\", \"samaccountname\");\n\t\treturnMap.put(\"identityAttributeValue\", finalManager);\n\t}\n\t\n\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", return: \" +returnMap);\n\treturn returnMap;\n\n  "
                },
                "attributes": {
                    "sourceVersion": "2025-04-22 04:18:40"
                },
                "id": "090f245ec14e46ad8d1762f3acecd252",
                "name": "Employee and Contractor - Manager Correlation TWF",
                "created": "2025-04-22T04:18:40.730Z",
                "modified": "2025-04-22T04:18:40.730Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "2f454a83382f49b89bd1fbe6b3de8904",
                "name": "ServiceNow Dummy App BeforeProvisioning"
            },
            "object": {
                "description": "This rule will be used to update the provisioning plan before it is sent to the connector",
                "type": "BeforeProvisioning",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2024-01-24 04:20:03",
                    "script": "\n    import sailpoint.object.Identity;\n    import sailpoint.object.ProvisioningPlan;\n    import sailpoint.object.ProvisioningPlan.AccountRequest;\n    import sailpoint.object.ProvisioningPlan.AttributeRequest;\n    import sailpoint.object.ProvisioningPlan.Operation;\n    import sailpoint.tools.Util;\n    import org.apache.commons.lang.StringUtils;\n    import sailpoint.rule.Account;\n    import java.util.List;\n    import java.util.ArrayList;\n    import java.util.Arrays;\n    import java.util.Iterator;\n\n  if (plan != null)\n\t{\t\n    log.error(\"Starting IGM Plan update in SNOW Dummy App before Provisioning Rule\");\n\t  List accountRequests = plan.getAccountRequests();\n\t    if(accountRequests != null)\n\t    {\n        for(AccountRequest accountRequest : accountRequests)\n        {\n          AccountRequest.Operation op = accountRequest.getOperation();\n          if(op != null && op.equals(AccountRequest.Operation.Modify))\n          {\n            String nativeIdentity = accountRequest.getNativeIdentity();\n            String applicationName = application.getName();\n            Account serviceNowAccount = idn.getAccountByNativeIdentity(applicationName, nativeIdentity);\n            Map attributes = serviceNowAccount.getAttributes(); \n            Object groups = attributes.get(\"groups\");\n            \n            log.error(\"Starting SNOW Dummy - Modify use case\");\n            List attributeReq = accountRequest.getAttributeRequests();\n            if(attributeReq != null && !attributeReq.isEmpty())\n            {\n              for(AttributeRequest attribute : attributeReq)\n                {\n                  if (attribute.getName().equals(\"groups\")) {\n                        log.error(\"SNOW Dummy - Modify operation with group change recognized\");\n                        String attrOp = attribute.getOperation().toString();\n                        if (attribute.getValue().toString().equalsIgnoreCase(\"deleted_group\")&& \"Add\".equalsIgnoreCase(attrOp)){\n                          if (groups != null) {\n                            if (groups instanceof List) {\n                                for (String groupName : groups) {\n                                    accountRequest.add(new AttributeRequest(\"groups\", ProvisioningPlan.Operation.Remove, groupName));\n                                }\n                            } else if (groups instanceof String) {\n                                // it is a single record\n                                String groupName = (String) groups;\n                                accountRequest.add(new AttributeRequest(\"groups\", ProvisioningPlan.Operation.Remove, groupName));\n                            }\n                          }\n                        }\n                  }\n                  else {\n                        log.error(\"SNOW Dummy - No actions needed\");\n                  }\n                }\n            }\n            log.error(\"Ending Modify-use-case mapping\");\n          }\n        }\n      }\n\t    log.error(\"IGM Plan update in SNOW Dummy App before Provisioning Rule is complete\");\n\t}\n\t\n  "
                },
                "attributes": {
                    "sourceVersion": "2024-01-24 04:20:03"
                },
                "id": "2f454a83382f49b89bd1fbe6b3de8904",
                "name": "ServiceNow Dummy App BeforeProvisioning",
                "created": "2024-01-18T21:53:30.960Z",
                "modified": "2024-01-24T04:20:03.772Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "35460b8d0ef04fd88a8f1670b2781164",
                "name": "GenerateUniqueMail"
            },
            "object": {
                "description": "Generate a unique mail attribute",
                "type": "AttributeGenerator",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2023-03-14 15:21:12",
                    "script": "\n    /*\n    * Generate a unique mail attribute\n    * \n    * Business rules\n    *   First Name + Last Name {number} @ Email Domain \n    *   First Name = first name of identity\n    *   Last Name = last name of identity \n    *   {number} = '' or 1..N for uniqueness\n    *\n    */\n   import java.util.Iterator;\n   import sailpoint.object.*;\n   import java.util.Arrays;\n   import java.util.ArrayList;\n   import java.util.List;\n   import java.lang.IllegalStateException;\n   import org.apache.commons.lang.StringUtils;\n   \n   \n   public String substituteCanadianFrenchCharacters(String input) {\n     String retVal = \"\";\n   \n     if (input.matches(\".*[\\u00E0\\u00C0\\u00E2\\u00C2\\u00E7\\u00C7\\u00E9\\u00C9\\u00E8\\u00C8\\u00EA\\u00CA\\u00EB\\u00CB\\u00EE\\u00CE\\u00EF\\u00CF\\u00F4\\u00D4\\u00FB\\u00DB\\u00FC\\u00DC\\u00F9\\u00D9\\u00FF\\u0178\\u0153\\u0152\\u00E6\\u00C6].*\")) {\n   \n       char[] characters = input.toCharArray();\n   \n       for (int idx = 0; idx < characters.length; idx++) {\n   \n         char currentCharacter = characters[idx];\n   \n         if (currentCharacter == '\\u00E0') {\n           retVal += \"a\";\n         } else if (currentCharacter == '\\u00C0') {\n           retVal += \"A\";\n         } else if (currentCharacter == '\\u00E2') {\n           retVal += \"a\";\n         } else if (currentCharacter == '\\u00C2') {\n           retVal += \"A\";\n         } else if (currentCharacter == '\\u00E7') {\n           retVal += \"c\";\n         } else if (currentCharacter == '\\u00C7') {\n           retVal += \"C\";\n         } else if (currentCharacter == '\\u00E9' ||\n                    currentCharacter == '\\u00E8' ||\n                    currentCharacter == '\\u00EA' ||\n                    currentCharacter == '\\u00EB') {\n           retVal += \"e\";\n         } else if (currentCharacter == '\\u00C9' ||\n                    currentCharacter == '\\u00C8' ||\n                    currentCharacter == '\\u00CA' ||\n                    currentCharacter == '\\u00CB') {\n           retVal += \"E\";\n         } else if (currentCharacter == '\\u00EE' ||\n                    currentCharacter == '\\u00EF' ) {\n           retVal += \"i\";\n         } else if (currentCharacter == '\\u00CE' ||\n                    currentCharacter == '\\u00CF') {\n           retVal += \"I\";\n         } else if (currentCharacter == '\\u00F4') {\n           retVal += \"o\";\n         } else if (currentCharacter == '\\u00D4') {\n           retVal += \"O\";\n         } else if (currentCharacter == '\\u00FB' ||\n                    currentCharacter == '\\u00FC' ||\n                    currentCharacter == '\\u00F9') {\n           retVal += \"u\";\n         } else if (currentCharacter == '\\u00DB' ||\n                    currentCharacter == '\\u00DC' ||\n                    currentCharacter == '\\u00D9' ) {\n           retVal += \"U\";\n         } else if (currentCharacter == '\\u00FF') {\n           retVal += \"y\";\n         } else if (currentCharacter == '\\u0178') {\n           retVal += \"Y\";\n         } else if (currentCharacter == '\\u0153') {\n           retVal += \"oe\";\n         } else if (currentCharacter == '\\u0152') {\n           retVal += \"OE\";\n         } else if (currentCharacter == '\\u00E6') {\n           retVal += \"ae\";\n         } else if (currentCharacter == '\\u00C6') {\n           retVal += \"AE\";\n         } else {\n           retVal += currentCharacter;\n         }\n       }\n     } else {\n       retVal = input;\n     }\n   \n     return retVal;\n   \n   }\n   \n   public boolean isUnique(String identityName, String applicationName, String email, String sourceId ) {\n       boolean isUnique = false;\n   \n       List matchCriteria = new ArrayList(Arrays.asList(new String[] { email }));\n       List sourceIds = new ArrayList(Arrays.asList(new String[] {sourceId}));\n   \n       int nbrMatches = idn.attrSearchCountAccounts(sourceIds, \"mail\", \"Equals\", matchCriteria);\n       log.error(\"GenerateUniqueMail nbrMatches: \" + String.valueOf(nbrMatches));\n   \n       int nbrIdentities = idn.countIdentitiesBySearchableIdentityAttribute(\"email\",\"Equals\",email);\n       log.error(\"GenerateUniqueMail nbrIdentities: \" + String.valueOf(nbrIdentities));\n   \n       boolean isUniqueLdapValue = idn.isUniqueLDAPValue(identityName, applicationName, \"mail\", email);\n   \n       if (nbrMatches == 0 && nbrIdentities == 0 && isUniqueLdapValue) {\n         isUnique = true;\n       }\n   \n       return isUnique;\n   }\n   \n   String sourceId = application.getId();\n   String fieldName = field.getName();\n   String lastName = identity.getAttribute(\"lastname\");\n   String firstName = identity.getAttribute(\"firstname\");\n   String domain = identity.getAttribute(\"emailDomain\");\n   String mail = null;\n   String postFix = \"\";\n   \n   // Note: debug only works with local mocked project, not when deployed\n   log.debug(\"GenerateUniqueEmail fieldName: \" + fieldName + \" lastName:\" + lastName + \" firstName:\" + firstName + \" sourceId: \" + sourceId);\n   \n   // Handle diacritial characters in first and last names\n   lastName = substituteCanadianFrenchCharacters(lastName);\n   firstName = substituteCanadianFrenchCharacters(firstName);\n   log.debug(\"GenerateUniqueEmail after french char substitution: lastName:\" + lastName + \" firstName:\" + firstName);\n   \n   // Remove punctuation\n   lastName = lastName.replaceAll(\"[^a-zA-Z0-9]\",\"\");\n   firstName = firstName.replaceAll(\"[^a-zA-Z0-9]\",\"\");\n   log.debug(\"GenerateUniqueEmail after filtering punctionation and spaces: lastName:\" + lastName + \" firstName:\" + firstName);\n   \n   // Try 1000 times, checking if unique\n   for (int iter = 0; iter < 1000; iter++) {\n   \n     if (iter == 0) {\n       postFix = \"\";\n     } else {\n       postFix = String.valueOf(iter);\n     }\n   \n     mail = firstName + \".\" + lastName + postFix + \"@\" + domain;\n   \n     if (isUnique(identity.getName(), application.getName(), mail, sourceId)) {\n       return mail; // Positive Outcome\n     }\n   }\n   \n   // Didn't find a unique one, can't try forever, so bail. Based on testing, returning null resulted in random value.\n   throw new IllegalStateException(\"GenerateUniquemail: iteration count of 1000 was exceeded\");\n   \n   return null; // won't get here, unclear if it can be left out.\n\n  "
                },
                "attributes": {
                    "sourceVersion": "2023-03-14 15:21:12"
                },
                "id": "35460b8d0ef04fd88a8f1670b2781164",
                "name": "GenerateUniqueMail",
                "created": "2023-01-26T15:11:32.172Z",
                "modified": "2023-03-14T15:21:13.373Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "3561c6dfe4e74f0bb44691b5bd3d4f63",
                "name": "GenerateUniqueSAMAccountName"
            },
            "object": {
                "description": "Generate a unique sAMAccountName",
                "type": "AttributeGenerator",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2023-05-08 12:48:57",
                    "script": "\n    /*\n    * Generate a unique sAMAccountName\n    * \n    * Business rules\n    *   1 Maximum 7 characters \n    *   2 first 5 letters of the LastName + 1st letter of the FirstName followed by 1 \n    *   3 If the LastName does not contain 5 letters, the remaining letters from the FirstName will be used followed by 1 \n    *   4 Check uniqueness against all AD accounts and AD sAMAccountName identity attribute. If not unique, increment numeric suffix \n    *   5 uppercase\n    *\n    */\n   import java.util.Iterator;\n   import sailpoint.object.*;\n   import sailpoint.rule.Account;\n   import java.util.Arrays;\n   import java.util.ArrayList;\n   import java.util.List;\n   import java.lang.IllegalStateException;\n   import org.apache.commons.lang.StringUtils;\n   import java.text.Normalizer;\n   \n   int MAX_LENGTH = 7;\n   int MAX_LASTNAME_LENGTH = 5;\n   int MIN_FIRSTNAME_LENGTH = 1;\n   int INITIAL_SUFFIX = 1;\n   \n   public String substituteCanadianFrenchCharacters(String input) {\n     String retVal = \"\";\n   \n     if (input.matches(\".*[\\u00E0\\u00C0\\u00E2\\u00C2\\u00E7\\u00C7\\u00E9\\u00C9\\u00E8\\u00C8\\u00EA\\u00CA\\u00EB\\u00CB\\u00EE\\u00CE\\u00EF\\u00CF\\u00F4\\u00D4\\u00FB\\u00DB\\u00FC\\u00DC\\u00F9\\u00D9\\u00FF\\u0178\\u0153\\u0152\\u00E6\\u00C6].*\")) {\n   \n       char[] characters = input.toCharArray();\n   \n       for (int idx = 0; idx < characters.length; idx++) {\n   \n         char currentCharacter = characters[idx];\n   \n         if (currentCharacter == '\\u00E0' || currentCharacter == '\\u00C0' ||\n             currentCharacter == '\\u00E2' || currentCharacter == '\\u00C2') {\n           retVal += \"A\";\n         } else if (currentCharacter == '\\u00E7' || currentCharacter == '\\u00C7') {\n           retVal += \"C\";\n         } else if (currentCharacter == '\\u00E9' || currentCharacter == '\\u00C9' ||\n                    currentCharacter == '\\u00E8' || currentCharacter == '\\u00C8' ||\n                    currentCharacter == '\\u00EA' || currentCharacter == '\\u00CA' ||\n                    currentCharacter == '\\u00EB' || currentCharacter == '\\u00CB') {\n           retVal += \"E\";\n         } else if (currentCharacter == '\\u00EE' || currentCharacter == '\\u00CE' ||\n                    currentCharacter == '\\u00EF' || currentCharacter == '\\u00CF') {\n           retVal += \"I\";\n         } else if (currentCharacter == '\\u00F4' || currentCharacter == '\\u00D4') {\n           retVal += \"O\";\n         } else if (currentCharacter == '\\u00FB' || currentCharacter == '\\u00DB' ||\n                    currentCharacter == '\\u00FC' ||\n                    currentCharacter == '\\u00DC' ||\n                    currentCharacter == '\\u00F9' ||\n                    currentCharacter == '\\u00D9' ) {\n           retVal += \"U\";\n         } else if (currentCharacter == '\\u00FF' || currentCharacter == '\\u0178') {\n           retVal += \"Y\";\n         } else if (currentCharacter == '\\u0153' || currentCharacter == '\\u0152') {\n           retVal += \"OE\";\n         } else if (currentCharacter == '\\u00E6' || currentCharacter == '\\u00C6') {\n           retVal += \"AE\";\n         } else {\n           retVal += currentCharacter;\n         }\n       }\n     } else {\n       retVal = input;\n     }\n   \n     return retVal;\n   \n   }\n   \n   public boolean isUnique(String identityName, String applicationName, String sAMAccountName, String sourceId, boolean checkIdentityAttribute ) {\n       boolean isUnique = false;\n       int nbrIdentities = 0;\n\n       List matchCriteria = new ArrayList(Arrays.asList(new String[] { sAMAccountName }));\n       List sourceIds = new ArrayList(Arrays.asList(new String[] {sourceId}));\n   \n       int nbrMatches = idn.attrSearchCountAccounts(sourceIds, \"samaccountname\", \"Equals\", matchCriteria);\n       log.error(\"GenerateUniqueSAMAccountName nbrMatches: \" + String.valueOf(nbrMatches));\n   \n       if (checkIdentityAttribute) {\n        nbrIdentities = idn.countIdentitiesBySearchableIdentityAttribute(\"samaccountname\",\"Equals\",sAMAccountName);\n        log.debug(\"GenerateUniqueSAMAccountName nbrIdentities: \" + String.valueOf(nbrIdentities));\n       } else {\n        log.debug(\"GenerateUniqueSAMAccountName skipping identity attribute search as trying to reuse for rehire\");\n       }\n\n       boolean isUniqueLdapValue = idn.isUniqueLDAPValue(identityName, applicationName, \"sAMAccountName\", sAMAccountName);\n       \n       //check among Legacy ids\n       Account legacyAcc = idn.getAccountByNativeIdentity(\"Legacy UserIds [source]\", sAMAccountName); \n   \n       if (nbrMatches == 0 && nbrIdentities == 0 && isUniqueLdapValue && legacyAcc == null) {\n         isUnique = true;\n       }\n   \n       return isUnique;\n   }\n   \n   String sourceId = application.getId();\n   String fieldName = field.getName();\n   String lastName = identity.getAttribute(\"lastname\");\n   String firstName = identity.getAttribute(\"firstname\");\n   String oldSAMAccountName = identity.getAttribute(\"samaccountname\");\n   String sAMAccountName = null;\n   int lastNameLength = lastName.length();\n   \n   // Note: debug only works with local mocked project, not when deployed\n   log.debug(\"GenerateUniqueSAMAccountName fieldName: \" + fieldName + \" lastName:\" + lastName + \" firstName:\" + firstName + \" oldSAMAccountName: \" + oldSAMAccountName + \" sourceId: \" + sourceId);\n   \n   // Requirement for rehire to reuse sAMAccountName, if there is one, then use it\n   // The identity profile keeps one based on oldValue if the AD Account was deleted\n   if (oldSAMAccountName != null && oldSAMAccountName.length() > 0) {\n     boolean isOldSAMAccountNameUnique = isUnique(identity.getName(), application.getName(), oldSAMAccountName, sourceId, false );\n     \n     if (isOldSAMAccountNameUnique) {\n       sAMAccountName = oldSAMAccountName.toUpperCase();\n       return sAMAccountName;\n     }\n   }\n\n  // Handle diacritial characters in first and last names\n  lastName = substituteCanadianFrenchCharacters(lastName);\n  firstName = substituteCanadianFrenchCharacters(firstName);\n  log.debug(\"GenerateUniqueSAMAccountName after french char substitution: lastName:\" + lastName + \" firstName:\" + firstName);\n  \n  // Remove punctuation\n  lastName = lastName.replaceAll(\"[^a-zA-Z0-9]\",\"\");\n  firstName = firstName.replaceAll(\"[^a-zA-Z0-9]\",\"\");\n  log.debug(\"GenerateUniqueSAMAccountName after filtering punctionation and spaces: lastName:\" + lastName + \" firstName:\" + firstName);\n  \n  // May have changed on processing\n  lastNameLength = lastName.length();\n  \n  if (lastNameLength < MAX_LASTNAME_LENGTH) {\n      sAMAccountName = lastName;\n      int nbrFirstNameChars = MAX_LASTNAME_LENGTH - lastNameLength + 1;\n      \n      if (nbrFirstNameChars > firstName.length()) {\n        sAMAccountName = sAMAccountName + firstName;\n      } else {\n        sAMAccountName = sAMAccountName + firstName.substring(0, nbrFirstNameChars);\n      }\n  \n  } else {\n      sAMAccountName = lastName.substring(0,MAX_LASTNAME_LENGTH) + firstName.substring(0,MIN_FIRSTNAME_LENGTH);\n  }\n  \n  if (StringUtils.isBlank(sAMAccountName)) {\n    throw new IllegalStateException(\"GenerateUniqueSAMAccountName: sAMAccountName was blank\");\n  }\n  \n  sAMAccountName = sAMAccountName.toUpperCase();\n\n  // Try 1000 times, checking if unique\n  for (int iter = 1; iter <= 60; iter++) {\n    String sAMAccountNameWithPostfix = sAMAccountName + String.valueOf(iter);\n    if (isUnique(identity.getName(), application.getName(), sAMAccountNameWithPostfix, sourceId, true )) {\n      return sAMAccountNameWithPostfix; // Positive Outcome\n    }\n  }\n   \n  // Didn't find a unique one, can't try forever, so bail. Based on testing, returning null resulted in random value.\n  throw new IllegalStateException(\"GenerateUniqueSAMAccountName: iteration count of 60 was exceeded\");\n   \n  return null; // won't get here, unclear if it can be left out.\n  "
                },
                "attributes": {
                    "sourceVersion": "2023-05-08 12:48:57"
                },
                "id": "3561c6dfe4e74f0bb44691b5bd3d4f63",
                "name": "GenerateUniqueSAMAccountName",
                "created": "2023-01-17T15:02:59.904Z",
                "modified": "2023-05-08T12:48:58.818Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "52af80a945424cf0ba5c21f4b4a0d9c7",
                "name": "SDIM Attributes"
            },
            "object": {
                "description": "Before Provisioning Rule which to add mandatory fields to Provisioning Plan for all Modify Operations",
                "type": "BeforeProvisioning",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2024-05-07 00:00:39",
                    "script": "\n    \n    import java.util.List;\n    import sailpoint.object.ProvisioningPlan;\n    import sailpoint.object.ProvisioningPlan.AccountRequest;\n    import sailpoint.object.ProvisioningPlan.AttributeRequest;\n    import sailpoint.object.Identity;\n    import sailpoint.object.*;\n    import java.util.HashMap;\n    import java.util.Map;\n    import java.time.Instant;\n    import java.time.ZoneId;\n    import java.time.ZonedDateTime;\n    import java.time.format.DateTimeFormatter;\n    import sailpoint.rule.Account;\n    \n    //Key = Identity Attribute    Value = Account Attribute\n    Map attributeTranslationMap = new HashMap();\n\n    attributeTranslationMap.put(\"firstname\",\"userFirstName\");\n    attributeTranslationMap.put(\"lastname\",\"userLastName\");\n    attributeTranslationMap.put(\"userType\",\"userUserType\");\n    attributeTranslationMap.put(\"startDate\",\"userStartDate\");\n    attributeTranslationMap.put(\"endDate\",\"userEndDate\");\n    attributeTranslationMap.put(\"language\",\"userLanguage\");\n    attributeTranslationMap.put(\"department\",\"userDepartment\");\n    attributeTranslationMap.put(\"company\",\"userCompany\");\n    attributeTranslationMap.put(\"manager\",\"managerFullName\");\n    attributeTranslationMap.put(\"title\",\"jobTitle\");\n    attributeTranslationMap.put(\"samaccountname\",\"samaccountname\");\n    attributeTranslationMap.put(\"provinceState\",\"userProvince\");\n    attributeTranslationMap.put(\"country\",\"userCountry\");\n    attributeTranslationMap.put(\"uid\",\"useruid\");\n    attributeTranslationMap.put(\"email\",\"userEmail\");\n    attributeTranslationMap.put(\"subscriptionIndicator\",\"usersubscriptionIndicator\");\n    attributeTranslationMap.put(\"repRelationships\",\"userrepRelationships\");\n    attributeTranslationMap.put(\"rgofname\",\"userrgofname\");\n    attributeTranslationMap.put(\"rgofno\",\"userrgofno\");\n    attributeTranslationMap.put(\"street\",\"userCity\");\n    attributeTranslationMap.put(\"workPhone\",\"userworkPhone\");\n    attributeTranslationMap.put(\"dealernum\",\"userdealernum\");\n    attributeTranslationMap.put(\"displayTitle\",\"userdisplayTitle\");\n    attributeTranslationMap.put(\"loaEndDate\",\"userLoaEndDate\");\n    attributeTranslationMap.put(\"loaStartDate\",\"userLoaStartDate\");\n\n    String acctOp = null, attrOp = null;\n    Boolean autoClose = false;\n    String ASSIGNMENTGROUP_DEFAULT = \"4d1176a51bc50190eadefd1b1e4bcbde\";\n    String ASSIGNMENTGROUP_GY = \"12cb0edf8728a950d67f4229dabb3538\";\n    String REQUESTEDBY_SLPTUSR = \"3ef2a6c51bc5e19001cf2f82b24bcb11\";\n\n    log.error(\"Entering SDIM Integration rule\");\n    if( plan != null ){\n        if (plan.getIdentity() != null && plan.getAccountRequests() != null){\n            List accountRequests = plan.getAccountRequests();\n            Identity identity = plan.getIdentity();\n            \n            \n            Map arguments = (Map)plan.getArguments();\n            List requesterList = plan.getRequesters();\n            Identity requester = null;\n            if (requesterList != null && requesterList.size() > 0) {\n                requester = requesterList.get(0);\n            }\n\n            String appName = integration.getName();\n            String requesterSource = null;\n            String identityFirstname = null;\n            String identityLastname = null;\n            String requester_nativeIdentity=null;\n            log.error(\"SDIM Rule Integration Name: \" + appName);\n            if (appName != null) {\n                requesterSource = (String)idn.getSourceAttributeBySourceName(appName, \"requesterSource\");\n            }\n            log.error(\"SDIM Rule requesterSource: \" + requesterSource);\n\n            log.error(\"Starting default integration mapping\");\n            // Get Account's native Identity (aka unique accountId)\n            String openedBy = null;\n            String requestedFor = null;\n            if (requesterSource != null) {\n                if (requester != null) {\n                    openedBy = idn.getFirstAccountNativeIdentity(requesterSource, requester.getName());\n                    log.error(\"SDIM Rule openedBy: \" + openedBy);\n                }\n                if (identity != null) {\n                    //getsamaccountname\n                    requester_nativeIdentity = idn.getFirstAccountNativeIdentity(requesterSource, identity.getName());\n                    requestedFor = idn.getRawAccountAttribute(requesterSource, requester_nativeIdentity, \"email\");\n                    log.error(\"SDIM Rule requestedFor: \" + requestedFor);\n                }\n            } else {\n                log.warn(\"Attribute 'requesterSource' is null in the application: \" + appName);\n            }\n\n            if(arguments == null){\n                arguments = new Attributes();\n            }\n            \n            if (identity != null) {\n                identityFirstname = identity.getFirstname();\n               identityLastname = identity.getLastname();\n            }\n    \n            if (requestedFor != null) {\n                arguments.put(\"requested_for\", requestedFor);\n            }\n\n            if (openedBy != null) {\n                arguments.put(\"opened_by\", openedBy);\n                arguments.put(\"requested_by\", openedBy);\n            }\n\n            if (identity.getName() != null) {\n                arguments.put(\"identityName\", identity.getName());\n            }\n            log.error(\"SDIM Rule Mapping output identityFirstname: \" + identityFirstname + \" identityLastname: \" + identityLastname + \" requestedFor \" + requestedFor + \" openedBy \" + openedBy + \" identityName: \" + identity.getName());\n    \n            log.error(\"Starting custom integration mapping\");\n\n            if (identity != null ){\n                if (accountRequests != null){\n                    for (AccountRequest accountRequest : accountRequests){\n                        for(String attributeKey : attributeTranslationMap.keySet() ) {\n                            if(identity.getStringAttribute(attributeKey) != null && accountRequest.getAttributeRequest(attributeTranslationMap.get(attributeKey)) == null ){\n                                arguments.put(attributeTranslationMap.get(attributeKey), identity.getStringAttribute(attributeKey));\n                                log.error(\"Initial attributes mapped to integration\");\n                            }\n                        }    \n                            \n                        //Types of operation\n                        //Create - joiner (active, prehire)\n                        //Modify - (mover,conversion - employeetype change, suspend) - change in the following Manager, Title, Cost Center, End date.\n                        //Enable - rehire, unsuspend\n                        //Disable - remove entitlement, (not disable operation), immediate termination - disable operation, lcs is termination, and no end date | suspend - remove entitlement with disable\n                        //Modify Operation\n                        //Mover - Advisors and employees - change in manager, title or cost center || Contractor - change in manager, title, cost center or enddate\n                        //Conversion - employee type change - group/entitlement added or removal then check what is addded or removed.\n                        //Delete added to modify operation\n                        //1.Rehire - Check if add groups = advisor_group,contractor_group, employee_group && Remove groups = terminated_group\n                        //2.Unsuspend - Check if add groups = advisor_group,contractor_group, employee_group && Remove groups = suspended_group\n\n                        acctOp = accountRequest.getOperation().toString();\n                        String lcs = identity.getAttribute(\"cloudLifecycleState\").toString().toLowerCase();\n                        String employeeType = identity.getAttribute(\"userType\");\n                        \n                        log.error(\"Starting operation-use-case mapping\");\n                        //Joiner Event - Account creation and LCS state is active or prehire\n                        if(acctOp != null && \"Create\".equalsIgnoreCase(acctOp)){\n                            log.error(\"Starting joiner-use-case mapping\");\n                            arguments.put(\"eventType\", \"Joiner\");\n                            //Put as \"Test\" because as per current issue, Event type is coming up as empty, so for now all joiner tickets are going to Grave Yard group\n                            if(employeeType != null && !employeeType.equalsIgnoreCase(\"Advisor\")){\n                                autoClose = true;\n                            }\n                            log.error(\"Ending joiner-use-case mapping\");\n                        }\n                        else if(acctOp != null && \"Modify\".equalsIgnoreCase(acctOp)){\n\n                            log.error(\"Starting Modify-use-case mapping\");\n\n                            String nativeIdentity = accountRequest.getNativeIdentity();\n                            Account serviceNowAccount = idn.getAccountByNativeIdentity(\"ServiceNow Dummy App [source]\", nativeIdentity);\n                            Map attributes = serviceNowAccount.getAttributes(); \n                            Object groups = attributes.get(\"groups\");\n                            boolean cleanUpGroups = false;\n\n                            log.error(\"Group attribute mapping set\");\n                            List attributeReq = accountRequest.getAttributeRequests();\n                            if(attributeReq != null && !attributeReq.isEmpty())\n                            {\n                                for(AttributeRequest attribute : attributeReq)\n                                    {\n                                    \n                                    if (attribute.getName().equals(\"manager\") || attribute.getName().equals(\"title\") || attribute.getName().equals(\"department\") || attribute.getName().equals(\"firstname\") || attribute.getName().equals(\"lastname\") || attribute.getName().equals(\"language\") || attribute.getName().equals(\"title\") || attribute.getName().equals(\"subscriptionIndicator\") || attribute.getName().equals(\"repRelationships\") || attribute.getName().equals(\"rgofname\") || attribute.getName().equals(\"rgofno\"))\n                                    {\n                                            arguments.put(\"eventType\", \"Mover\");\n                                            log.error(\"Modify operation with attribute change recognized\");\n                                            if(employeeType != null && !employeeType.equalsIgnoreCase(\"Advisor\")){\n                                                autoClose = true;\n                                            }\n                                    }\n                                    //if it falls out of above conditions then autoclose the ticket for modify\n                                    else if (attribute.getName().equals(\"groups\")) {\n                                        log.error(\"Modify operation with group change recognized\");\n                                        String attrOp = attribute.getOperation().toString();\n                                        if ((\"Add\".equalsIgnoreCase(attrOp)) || (\"Remove\".equalsIgnoreCase(attrOp))) {\n                                            //Use case - Delete to active or prehire first ticket creation\n                                           if ((attribute.getValue().toString().equalsIgnoreCase(\"deleted_group\")) && \"Remove\".equalsIgnoreCase(attrOp) && (lcs.equals(\"active\")|| lcs.equals(\"prehire\"))) {\n                                                arguments.put(\"eventType\", \"Rehire\");\n                                                if(employeeType != null && !employeeType.equalsIgnoreCase(\"Advisor\")){\n                                                    autoClose = true;\n                                                }\n                                            } \n                                            //Use case - Suspended to any active group ticket creation\n                                            else if (attribute.getValue().toString().equalsIgnoreCase(\"suspended_group\") && \"Remove\".equalsIgnoreCase(attrOp)) {\n                                                arguments.put(\"eventType\", \"Reactivate\");\n                                                autoClose = false;\n                                            }\n                                            //Use case - Terminated to Active or prehire and Delete to Active or prehire second ticket creation\n                                            else if ((attribute.getValue().toString().equalsIgnoreCase(\"contractor_group\") || attribute.getValue().toString().equalsIgnoreCase(\"advisor_group\") || attribute.getValue().toString().equalsIgnoreCase(\"employee_group\")) && \"Add\".equalsIgnoreCase(attrOp) && (lcs.equals(\"active\") || lcs.equals(\"prehire\")) ) {\n                                                String existingEventType = (String) arguments.get(\"eventType\");\n                                                if(existingEventType == null || existingEventType.isEmpty() || existingEventType.equalsIgnoreCase(\"Group change not recognized\")) {\n                                                    arguments.put(\"eventType\", \"Rehire\");\n                                                    if(employeeType != null && !employeeType.equalsIgnoreCase(\"Advisor\")){\n                                                        autoClose = true;\n                                                    }\n                                                }\n                                            } \n                                            else if (lcs.equals(\"terminated\"))\n                                            {\n                                                arguments.put(\"eventType\", \"Termination\");\n                                            }\n                                            else if (lcs.equals(\"suspended\"))\n                                            {\n                                                arguments.put(\"eventType\", \"Suspend\");\n                                            }\n                                            else if (lcs.equals(\"deleted\"))\n                                            {\n                                                arguments.put(\"eventType\", \"Delete\");\n                                            }\n                                            else {\n                                                log.error(\"Modify group change not recognized\");\n                                                arguments.put(\"eventType\", \"Group change not recognized\");\n                                            }\n\n                                            if (attribute.getValue().toString().equalsIgnoreCase(\"deleted_group\")&& \"Add\".equalsIgnoreCase(attrOp)){\n                                                cleanUpGroups = true;\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        log.error(\"Modify event not recognized\");\n                                        autoClose = true;\n                                    }\n                                }\n                            }\n\n                            if (cleanUpGroups){\n                                if (groups != null) {\n                                  if (groups instanceof List) {\n                                      for (String groupName : groups) {\n                                          accountRequest.add(new AttributeRequest(\"groups\", ProvisioningPlan.Operation.Remove, groupName));\n                                      }\n                                  } else if (groups instanceof String) {\n                                      // it is a single record\n                                      String groupName = (String) groups;\n                                      accountRequest.add(new AttributeRequest(\"groups\", ProvisioningPlan.Operation.Remove, groupName));\n                                  }\n                                }\n                              }\n\n                            \n                            log.error(\"Ending Modify-use-case mapping\");\n                        }\n                        else {\n                            log.error(\"Starting Default case mapping\");\n                            arguments.put(\"eventType\", \"Invalid Event\");\n                            autoClose = true;\n                            log.error(\"Ending Default case mapping\");\n                        }\n\n                            \n                        if(acctOp != null){\n                            log.error(\"Starting autoclose mapping\");\n                            if (requestedFor==null){\n                                //change to email of sailpoint user in SNOW if requirements change\n                                arguments.put(\"requested_for\", REQUESTEDBY_SLPTUSR);\n                            }\n                            //auto-close ITSM tickets for ServiceNow Dummy App and create account\n                            if(autoClose){\n                                arguments.put(\"request_state\", \"closed_complete\");\n                                arguments.put(\"ticket_state\", \"3\");\n                                log.error(\"Autoclose TRUE\");\n                                //Populate the assignment groups\n                                arguments.put(\"assignment_group\", ASSIGNMENTGROUP_GY);\n                            }\n                            else {\n                                //Populate the assignment groups\n                                log.error(\"Autoclose FALSE\");\n                                arguments.put(\"assignment_group\", ASSIGNMENTGROUP_DEFAULT);\n                            }\n                            log.error(\"Ending autoclose mapping\");\n                        }                  \n                    }\n                }\n            }\n            if(arguments!=null){\n                plan.setArguments(arguments);\n            }\n        }\n    }\n "
                },
                "attributes": {
                    "sourceVersion": "2024-05-07 00:00:39"
                },
                "id": "52af80a945424cf0ba5c21f4b4a0d9c7",
                "name": "SDIM Attributes",
                "created": "2023-02-08T15:01:25.888Z",
                "modified": "2024-05-07T00:00:40.772Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "703ad8db99d34b158e8640aedda3d91b",
                "name": "Employee and Contractor - Manager Correlation Updated"
            },
            "object": {
                "description": "Employee and Contractor Manager Correlation.",
                "type": "ManagerCorrelation",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2024-11-08 19:38:57",
                    "script": "\n\n\timport sailpoint.object.Identity;\n\timport sailpoint.object.Link;\n\timport java.util.List;\n\timport java.util.Map;\n\timport java.util.HashMap;\n\timport sailpoint.api.SailPointContext;\n\timport sailpoint.server.IdnRuleUtil;\n\timport sailpoint.rule.Identity;\n\t\n\tMap returnMap = new HashMap();\n\tString finalManager = null;\n\tboolean userHasSAP = false;\n\tString sapEccManager = null, serviceNowManager = null;\n\t\n\tsailpoint.object.Identity identity =  link.getIdentity();\n\tString userType = identity.getAttribute(\"userType\");\n\tString userLCS = identity.getAttribute(\"cloudLifecycleState\");\n\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", userType: \" +userType+ \",userLCS: \" +userLCS);\n\t\n\tList userLinks = identity.getLinks();\n\tfor(Link link: userLinks){\n\t\tif(link.getApplicationName().equals(\"Employees SAP ECC [source]\")){\n\t\t\tuserHasSAP = true;\n\t\t\tsapEccManager = link.getAttribute(\"MANAGER\");\n\t\t}\n\t\tif(link.getApplicationName().equals(\"ServiceNowAPI [source]\")){\n\t\t\tserviceNowManager = link.getAttribute(\"manager\");\n\t\t}\n\t}\n\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", userHasSAP: \" +userHasSAP+ \", sapEccManager: \" +sapEccManager+ \", serviceNowManager: \"+serviceNowManager);\n\t\n\tif(userHasSAP && \"Employee\".equalsIgnoreCase(userType)){\n\t\t//If SAP ECC account exists, get manager from SAP ECC account\n\t\treturnMap.put(\"identityAttributeName\", \"employeeId\");\n\t\treturnMap.put(\"identityAttributeValue\", sapEccManager);\n\t}\n\telse {\n\t\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", user has no SAP ECC acct or Contractor\");\n\t\tif(null != serviceNowManager && \"Contractor\".equalsIgnoreCase(userType)){\n\t\t\tList managers = idn.findIdentitiesBySearchableIdentityAttribute(\"samaccountname\", \"Equals\", serviceNowManager, \"samaccountname\");\n\t\t\t\n\t\t\tif(null != managers && !managers.isEmpty() && (\"prehire\".equalsIgnoreCase(userLCS) || \"active\".equalsIgnoreCase(userLCS) || \"suspended\".equalsIgnoreCase(userLCS))){\n\t\t\t\tfor (sailpoint.rule.Identity manager : managers) {\n\t\t\t\t\tMap managerAttributes = manager.getAttributes();\n\t\t\t\t\tString managerLCS = (String) managerAttributes.get(\"cloudLifecycleState\");\n\t\t\t\t\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", managerLCS: \"+managerLCS);\n\t\t\t\t\t\n\t\t\t\t\tif(\"active\".equalsIgnoreCase(managerLCS)){\n\t\t\t\t\t\tfinalManager = serviceNowManager;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString superManagerId = manager.getManagerId();\n\t\t\t\t\t\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", superManagerId: \"+superManagerId);\n\t\t\t\t\t\t\n\t\t\t\t\t\tsailpoint.rule.Identity superManagerIdentity = idn.getIdentityById(superManagerId);\n\t\t\t\t\t\tif(superManagerIdentity != null){\n\t\t\t\t\t\t\tMap supermanAttributes = superManagerIdentity.getAttributes();\n\t\t\t\t\t\t\tfinalManager = (String) supermanAttributes.get(\"samaccountname\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfinalManager = serviceNowManager;\n\t\t}\n        returnMap.put(\"identityAttributeName\", \"samaccountname\");\n\t\treturnMap.put(\"identityAttributeValue\", finalManager);\n\t}\n\t\n\tlog.debug(\"manager correlation:: name: \" +identity.getName()+ \", return: \" +returnMap);\n\treturn returnMap;\n\n  "
                },
                "attributes": {
                    "sourceVersion": "2024-11-08 19:38:57"
                },
                "id": "703ad8db99d34b158e8640aedda3d91b",
                "name": "Employee and Contractor - Manager Correlation Updated",
                "created": "2024-10-30T23:00:58.267Z",
                "modified": "2024-11-08T19:38:57.728Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "7222aa701ccc4b538aff00a92ffc11f6",
                "name": "Epic SER Multivalued Update"
            },
            "object": {
                "description": "This rule will change \"Add\" and \"Remove\" multivalued attribute requests into \"Set\" requests. Existing\n        account attributes are read from the identity and added to the attribute request \"value\".\n        The operation is then changed to \"Set\". This allows for proper support of multivalued attributes for the Epic\n        SER connector. This is required because the connector does not have a native \"Add\" or \"Remove\" patch operation;\n        it only supports replace. It also does not support a native read for a single account, so this cannot be taken\n        care of within the connector logic.\n    ",
                "type": "BeforeProvisioning",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "1.0",
                    "script": "\n        \n            import sailpoint.object.ProvisioningPlan;\n            import sailpoint.object.Schema;\n            import sailpoint.rule.Account;\n            import sailpoint.tools.GeneralException;\n\n            private List objectToList(Object obj) {\n                if (obj instanceof Collection) {\n                    return new ArrayList((Collection) obj);\n                } else {\n                    return new ArrayList(Collections.singletonList(obj));\n                }\n            }\n\n            ////////////////////////////////////////////////////////////////\n            // Main\n            ////////////////////////////////////////////////////////////////\n            String logPrefix = \"MultivaluedUpdate - \";\n            log.trace(logPrefix + \"enter\");\n            if (plan == null || plan.getAccountRequests() == null) return;\n            log.trace(logPrefix + \"Account requests size: \" + plan.getAccountRequests().size());\n            Schema schema = application.getSchema(\"account\");\n            if (schema == null) {\n                log.warn(logPrefix + \"Could not get account schema. Exiting.\");\n                return;\n            }\n            for (ProvisioningPlan.AccountRequest accountRequest : plan.getAccountRequests()) {\n                if (accountRequest.getOp().equals(ProvisioningPlan.ObjectOperation.Create)) {\n                    continue;\n                }\n                if (accountRequest.getOp().equals(ProvisioningPlan.ObjectOperation.Delete)) {\n                    continue;\n                }\n                if (accountRequest.getAttributeRequests() == null) {\n                    continue;\n                }\n                log.trace(logPrefix + \"Attribute requests size: \" + accountRequest.getAttributeRequests().size());\n\n                for (ProvisioningPlan.AttributeRequest attributeRequest : accountRequest.getAttributeRequests()) {\n                    if (attributeRequest.getOp() == null || attributeRequest.getName() == null || attributeRequest.getValue() == null) {\n                        log.warn(logPrefix + \"Attribute request is missing op, name, or value..\");\n                        continue;\n                    }\n\n                    log.trace(logPrefix + \"attribute request name: \" + attributeRequest.getName() +\n                        \", value: \" + attributeRequest.getValue() + \", operation: \" + attributeRequest.getOp());\n\n                    if (!attributeRequest.getOp().equals(ProvisioningPlan.Operation.Add) &&\n                        !attributeRequest.getOp().equals(ProvisioningPlan.Operation.Remove)) {\n                        continue;\n                    }\n\n                    if (!schema.isMultiValued(attributeRequest.getName())) {\n                        log.trace(logPrefix + attributeRequest.getName() + \" is not multivalued. skipping.\");\n                        continue;\n                    }\n\n                    final String applicationName = accountRequest.getApplicationName() == null ?\n                        application.getName() :\n                        accountRequest.getApplicationName();\n                    if (applicationName == null) {\n                        log.error(logPrefix + \"ApplicationName not in accountRequest or application object\");\n                        continue;\n                    }\n                    log.debug(logPrefix + \"Application name: \" + applicationName);\n\n                    final String nativeIdentity = accountRequest.getNativeIdentity() == null ?\n                        plan.getNativeIdentity() :\n                        accountRequest.getNativeIdentity();\n                    if (nativeIdentity == null) {\n                        log.error(logPrefix + \"Native Identity not present in AccountRequest or ProvisioningPlan\");\n                        continue;\n                    }\n                    log.debug(logPrefix + \"nativeIdentity name: \" + nativeIdentity);\n\n                    final Account account = idn.getAccountByNativeIdentity(applicationName, nativeIdentity);\n                    if (account == null) {\n                        log.error(logPrefix + \"Could not find account for app \" + applicationName + \" and identity \" + nativeIdentity);\n                        continue;\n                    }\n                    log.debug(logPrefix + \"Found account with uuid: \" + account.getUuid());\n\n                    final Object rawExistingVals = idn.getRawAccountAttribute(account, attributeRequest.getName());\n                    if (rawExistingVals == null) {\n                        log.debug(logPrefix + \"Existing account attribute value is null for  \" + attributeRequest.getName() + \". Nothing to do.\");\n                        continue;\n                    }\n\n                    log.trace(logPrefix + \"Raw existing values class: \" + rawExistingVals.getClass());\n                    List targetValues = objectToList(rawExistingVals);\n\n                    final Object rawChangeVals = attributeRequest.getValue();\n                    log.trace(logPrefix + \"Attribute Request values class: \" + rawChangeVals.getClass());\n                    List changeVals = objectToList(rawChangeVals);\n\n                    if (attributeRequest.getOp().equals(ProvisioningPlan.Operation.Add)) {\n                        log.debug(logPrefix + \"AttributeRequest with ADD operation found name: \" + attributeRequest.getName());\n                        targetValues.addAll(changeVals);\n                        attributeRequest.setValue(targetValues);\n                        log.debug(logPrefix + \"Changing operation from \\\"Add\\\" to \\\"Set\\\"\");\n                        attributeRequest.setOp(ProvisioningPlan.Operation.Set);\n                        log.debug(logPrefix + \"Resulting target values: \" + targetValues);\n                    } else if (attributeRequest.getOp().equals(ProvisioningPlan.Operation.Remove)) {\n                        log.debug(logPrefix + \"AttributeRequest with REMOVE operation found name: \" + attributeRequest.getName());\n                        targetValues.removeAll(changeVals);\n                        attributeRequest.setValue(targetValues);\n                        log.debug(logPrefix + \"Changing operation from \\\"Remove\\\" to \\\"Set\\\"\");\n                        attributeRequest.setOp(ProvisioningPlan.Operation.Set);\n                        log.debug(logPrefix + \"Resulting target values: \" + targetValues);\n                    }\n                }\n            }\n            log.trace(logPrefix + \"exit\");\n        \n    "
                },
                "attributes": null,
                "id": "7222aa701ccc4b538aff00a92ffc11f6",
                "name": "Epic SER Multivalued Update",
                "created": "2023-09-26T16:32:52.519Z",
                "modified": "2025-08-12T01:05:20.264Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "7ad1314086d24d2399cc85c2cb8e34b9",
                "name": "TWF Manager Correlation"
            },
            "object": {
                "description": "Describe your rule here.",
                "type": "ManagerCorrelation",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2025-07-23 22:43:38",
                    "script": "\n/**\n * Purpose: provide manager correlation criteria based on best source amongst multiple candidate sources for IGM\n * 2025-07-22 Scott Walker      - Based on prior \"employeee and contractor - manager correlation\" rule which was also updated by Jyoti, \n *                              - This applies to all user types now as even advisors have managers and can be sourced from multiple authoritative sources\n *                              - earlier version from Jyoti worked however the underlying source had to be re-created to avoid name reference issues\n */\n\nimport sailpoint.object.Identity;\nimport sailpoint.object.Link;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport sailpoint.api.SailPointContext;\nimport sailpoint.server.IdnRuleUtil;\nimport sailpoint.rule.Identity;\n\t\nMap returnMap = new HashMap();\nString finalManager = null;\nboolean userHasSAP = false;\nString sapEccManager = null, serviceNowManager = null, SFNonAuthManager = null, SFAuthManager = null;\n\nsailpoint.object.Identity identity = link.getIdentity();\nString userType = identity.getAttribute(\"userType\");\nString userLCS = identity.getAttribute(\"cloudLifecycleState\");\nString bestSource = identity.getAttribute(\"sourceoftruth\");\nList userLinks = identity.getLinks();\n\nlog.error(\"manager correlation:: name: \" + identity.getName() + \", userType: \" + userType + \",userLCS: \" + userLCS + \",sourceoftruth: \" + bestSource);\n\nfor (Link link: userLinks) {\n    if (link.getApplicationName().equals(\"Employees SAP ECC [source]\")) {\n        userHasSAP = true;\n        sapEccManager = link.getAttribute(\"MANAGER\");\n    }\n    if (link.getApplicationName().equals(\"ServiceNowAPI [source]\")) {\n        serviceNowManager = link.getAttribute(\"manager\");\n    }\n    if (link.getApplicationName().equals(\"SuccessFactors-Auth [source]\")) {\n        SFAuthManager = link.getAttribute(\"ManagerID\");\n        log.error(\"manager correlation:: name: \" + identity.getName() + \"SuccessFactors-Auth\" + SFAuthManager);\n    }\n    if (link.getApplicationName().equals(\"SuccessFactors - InvestorsgT3 - Connection2 [source]\")) {\n        SFNonAuthManager = link.getAttribute(\"ManagerID\");\n        log.error(\"manager correlation:: name: \" + identity.getName() + \"SuccessFactors - NonAuthoritative\" + SFNonAuthManager);\n    }\n}\nlog.error(\"manager correlation:: name: \" + identity.getName() + \", userHasSAP: \" + userHasSAP + \", sapEccManager: \" + sapEccManager + \", serviceNowManager: \" + serviceNowManager);\n\nif (userHasSAP && \"use_SAPECC\".equalsIgnoreCase(bestSource)) {\n    //If SAP ECC account exists, get manager from SAP ECC account\n    returnMap.put(\"identityAttributeName\", \"employeeId\");\n    returnMap.put(\"identityAttributeValue\", sapEccManager);\n}\nelse if (\"use_SFAuth\".equalsIgnoreCase(bestSource)) {\n    returnMap.put(\"identityAttributeName\", \"personid\");\n    returnMap.put(\"identityAttributeValue\", SFAuthManager);\n    log.error(\"manager correlation:: name: \" + identity.getName() + \"SuccessFactors - NonAuthoritative Return Map\");\n}\nelse if (\"use_SFNonAuth\".equalsIgnoreCase(bestSource)) {\n    returnMap.put(\"identityAttributeName\", \"personid\");\n    returnMap.put(\"identityAttributeValue\", SFNonAuthManager);\n    log.error(\"manager correlation:: name: \" + identity.getName() + \"SuccessFactors - Authoritative Return Map\");\n}\nelse {\n    // this is basically a fall through case. It assumes this rule would not be used for identities with only the SIS source, so should not be used for the Advisors Identity Profile\n    log.error(\"manager correlation:: name: \" + identity.getName() + \" ServiceNowApi - Return Map\");\n\n    // previously we limited this to contractors only, but this could apply to employees who do not yet have a SAP ECC or SF source records correlated\n    if (null != serviceNowManager) {\n\n\t\tList managers = idn.findIdentitiesBySearchableIdentityAttribute(\"samaccountname\", \"Equals\", serviceNowManager, \"samaccountname\");\n\n        // we only expect or apply a manager for identities which are active or may become active in a normal flow\n        if (null != managers && !managers.isEmpty() && (\"prehire\".equalsIgnoreCase(userLCS) || \"active\".equalsIgnoreCase(userLCS) || \"suspended\".equalsIgnoreCase(userLCS))) {\n            for (sailpoint.rule.Identity manager : managers) {\n\t\t\t\tMap managerAttributes = manager.getAttributes();\n\t\t\t\tString managerLCS = (String) managerAttributes.get(\"cloudLifecycleState\");\n                log.debug(\"manager correlation:: name: \" + identity.getName() + \", managerLCS: \" + managerLCS);\n\n                if (\"active\".equalsIgnoreCase(managerLCS)) {\n                    finalManager = serviceNowManager;\n                } else {\n\t\t\t\t\tString superManagerId = manager.getManagerId();\n                    log.debug(\"manager correlation:: name: \" + identity.getName() + \", superManagerId: \" + superManagerId);\n\n                    sailpoint.rule.Identity superManagerIdentity = idn.getIdentityById(superManagerId);\n                    if (superManagerIdentity != null) {\n\t\t\t\t\t\tMap supermanAttributes = superManagerIdentity.getAttributes();\n                        finalManager = (String) supermanAttributes.get(\"samaccountname\");\n                    }\n                }\n                break;\n            }\n        }\n    }\n    else {\n        // this would be null\n        finalManager = serviceNowManager;\n    }\n    returnMap.put(\"identityAttributeName\", \"samaccountname\");\n    returnMap.put(\"identityAttributeValue\", finalManager);\n}\n\nlog.debug(\"manager correlation:: name: \" + identity.getName() + \", return: \" + returnMap);\nreturn returnMap;\n\n  "
                },
                "attributes": {
                    "sourceVersion": "2025-07-23 22:43:38"
                },
                "id": "7ad1314086d24d2399cc85c2cb8e34b9",
                "name": "TWF Manager Correlation",
                "created": "2025-07-23T22:43:38.331Z",
                "modified": "2025-07-23T22:43:38.331Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "85e4caa624d7463ba4a32f1bb69ec47d",
                "name": "SAP ECC Manager Correlation"
            },
            "object": {
                "description": "",
                "type": "ManagerCorrelation",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2023-07-09 23:58:42",
                    "script": "\n\nimport sailpoint.object.Identity;\nimport sailpoint.object.Link;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\n\nIdentity identity =  link.getIdentity();\nMap returnMap = new HashMap();\nList linkList = identity.getLinks();\nfor(Link link: linkList){\n  if(link.getApplicationName().equals( \"Employees SAP ECC [source]\")){\n   String sapEccManager = link.getAttribute( \"MANAGER\");\n   returnMap.put(\"identityAttributeName\", \"employeeId\");\n   returnMap.put(\"identityAttributeValue\", sapEccManager);\n   break;\n  } else if(link.getApplicationName().equals(\"ServiceNowAPI [source]\")){\n   String serviceNowManager = link.getAttribute( \"manager\");\n   returnMap.put(\"identityAttributeName\", \"samaccountname\");\n   returnMap.put(\"identityAttributeValue\", serviceNowManager);\n  }\n\n}\n\nreturn returnMap;\n\n  "
                },
                "attributes": {
                    "sourceVersion": "2023-07-09 23:58:42"
                },
                "id": "85e4caa624d7463ba4a32f1bb69ec47d",
                "name": "SAP ECC Manager Correlation",
                "created": "2023-06-19T20:29:19.008Z",
                "modified": "2023-07-09T23:58:43.528Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "8d95d1e70b5d4281a9518d1513996692",
                "name": "Active Directory BeforeProvisioning"
            },
            "object": {
                "description": "This rule will be used to update the provisioning plan before it is sent to the connector",
                "type": "BeforeProvisioning",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2025-07-29 07:22:25",
                    "script": "\nimport java.util.List;\nimport sailpoint.object.Application;\nimport sailpoint.object.Identity;\nimport sailpoint.object.ProvisioningPlan;\nimport sailpoint.object.ProvisioningPlan.AccountRequest;\nimport sailpoint.object.ProvisioningPlan.AttributeRequest;\nimport sailpoint.object.ProvisioningPlan.Operation;\nimport sailpoint.tools.Util;\n    \npublic AttributeRequest newAttributeRequest(String attributeName, Object attributeValue, ProvisioningPlan.Operation op) {\n\tAttributeRequest attributeRequest = new ProvisioningPlan.AttributeRequest();\n\n    attributeRequest.setName(attributeName);\n    attributeRequest.setOperation(op);\n    attributeRequest.setValue(attributeValue);\n\n    return attributeRequest;\n}\n\t\npublic String generateEmailAddress(String firstName, String lastName, String domain){\n\t\n\tString email = \"\";\n\n    if (Util.isNullOrEmpty(firstName) || Util.isNullOrEmpty(lastName) || Util.isNullOrEmpty(domain)) {\n        return null;\n    }\n   \t\t \n    String base = firstName + \".\" + lastName;\n    email = base + \"@\" + domain;\n    if (!isUnique(email, identity)) {\n        for (int count = 1; count < 100; count++) {\n            email = base + count + \"@\" + domain;\n            if (isUnique(email, identity)) {\n                break;\n            }\n        }\n    }\n\n    return email;\n\n}\n\n\n//This method checks uniqueness of generated email\npublic boolean isUnique(String email, Identity identity){\n    boolean isUnique = false;\n\n    //check uniqueness in AD\n    if (idn.isUniqueLDAPValue(identity.getName(), application.getName(), \"mail\", email)) {\n        isUnique = true;\n    }\n\n    return isUnique;\n}\n\n/**\n * Upated By Rakesh Kapoor 03/14/2024\n * Updated 03/19/2024\n * Updated 03/21/2024\n * 2024-04-03 Scott Walker      Re-org main and add comments to help diagnose failure to update AD attributes \n * 2024-04-04 Scott Walker      Remove extentionAttribute12 assignment to determine if this is the cause of attribute update failures\n * 2024-04-08 Scott Walker      Clean up debugging code and submit candidate final version for Immed susp/term enhancement.\n * 2025-07-23 Khilan Shah       Updated script to set msExchHideFromAddressLists and  msExchRequireAuthToSendTo false by default for suspended LCS.\n * Main Program Starts Here\n */\n\n// Give name of the source SNOWReqParams \nString SNOWReqParams = \"SNOWReqParams [source]\";\n\nif (plan != null) {\n    String currentLcs = \"\";\n    String deletedLcs = \"deleted\";\n\tString suspendedLcs = \"suspended\";\n    String firstname = \"\";\n    String lastname = \"\";\n    String truestring = \"true\";\n\n    Identity identity = plan.getIdentity();\n    if (identity != null) {\n        currentLcs = (String) identity.getAttribute(\"cloudLifecycleState\");\n        firstname = (String) identity.getAttribute(\"firstname\");\n        lastname = (String) identity.getAttribute(\"lastname\");\n\n    }\n\n    // get the account request object/list\n    List accountRequests = plan.getAccountRequests();\n\n    if (accountRequests != null) {\n        for (AccountRequest accountRequest : accountRequests) {\n            AccountRequest.Operation op = accountRequest.getOperation();\n            log.debug(\"IGM AD Provisioning Rule: currentLcs state: \" + currentLcs);\n\n\n            if (op != null && AccountRequest.Operation.Enable.equals(op) && deletedLcs.equals(currentLcs)) {\n                /* SW - IGMs requirement is to actually delete active directory accounts when they are moved to a final phase of offboarding. \n                 * SailPoint IDN/ISC does not have a built in option for this in the account provisioning, it seems to have the view\n                 * that accounts would be disabled or perhaps moved to a seperate OU, but not deleted. Due to this we must [a] distinguish AD provisioning \n                 * settings between the initial offboarding state (terminated) and the final offboarding state (deleted) by configuring 'delete' to \n                 * look like it will enable the account again (i.e. to trigger the provisioning plan creation) but then [b] override the \n                 * accountRequest operation to Disable via this rule based on the LCS value of 'deleted'. \n                 */\n                log.debug(\"Enable request for user with deleted LCS. Updating account request with Delete operation\");\n                accountRequest.setOperation(AccountRequest.Operation.Delete);\n            } else if (op != null && AccountRequest.Operation.Enable.equals(op) && !deletedLcs.equals(currentLcs)) {\n\n                log.debug(\"Enable request for user without deleted LCS. Clearing attributes msExchHideFromAddressLists and msExchRequireAuthToSendTo\");\n\n                //Add attribute request for msExchHideFromAddressLists and msExchRequireAuthToSendTo\n                accountRequest.add(newAttributeRequest(\"msExchHideFromAddressLists\", false, ProvisioningPlan.Operation.Set));\n                accountRequest.add(newAttributeRequest(\"msExchRequireAuthToSendTo\", false, ProvisioningPlan.Operation.Set));\n\n                //Add attribute request for AuthOrig\n                accountRequest.add(newAttributeRequest(\"authOrig\", \"\", ProvisioningPlan.Operation.Set));\n\n            } else if (op != null && AccountRequest.Operation.Disable.equals(op) && suspendedLcs.equals(currentLcs)) {\n\n                String mailboxHideFromGAL = \"false\";\n                String mailboxBlockIncomingEmail = \"false\";\n\n                log.debug(\"Enable request for user with suspended LCS. Resetting attributes msExchHideFromAddressLists and msExchRequireAuthToSendTo\");\n\n                String aDAcctNativeID = accountRequest.getNativeIdentity();\n                \n                /**\n                 * Rakash leverages the happenstance that identity name and NativeID of source\n                 * SNOWReqParam account would be the same value (as configured).\n                 */\n                String SRPAcctNativeIdentity = identity.getName();\n\n                /** \n                  * Depending on the LCS change scenario for the identity in question when an AD account is disabled there may or \n                  * may not be a  SNOWReqParam account for the identity. IF there is one then we want to use the specified flag \n                  * settings in that record for mailbox behavior.\n                  */\n                if (SRPAcctNativeIdentity != null && idn.accountExistsByDisplayName(SNOWReqParams, SRPAcctNativeIdentity)) {\n                    log.debug(\"SNOWReqParams source record exists for identity\");\n\n                    /* gather values from SNOWReqParam */\n                    mailboxHideFromGAL = idn.getAccountAttribute(SNOWReqParams, SRPAcctNativeIdentity, \"mailboxHideFromGAL\").toString().toLowerCase();\n                    mailboxBlockIncomingEmail = idn.getAccountAttribute(SNOWReqParams, SRPAcctNativeIdentity, \"mailboxBlockIncomingEmail\").toString().toLowerCase();\n                    /* may wan to put some debug output here to show the values obtained */\n\n                    /* if values are empty then override to default value */\n                    if (mailboxHideFromGAL == null) {\n                        mailboxHideFromGAL = \"true\";\n                    }\n                    if (mailboxBlockIncomingEmail == null) {\n                        mailboxBlockIncomingEmail = \"true\";\n                    }\n                    /** 2024-04-08\n                     * Assigning the requestor email to extentionAttribute12 was causing failures possibly due to AD settings so we do not \n                     * use an AD attribute to pass that information to the script. Instead the script must do account api calls to obtain\n                     * the value for notifications.\n                     */\n                    accountRequest.add(newAttributeRequest(\"msExchHideFromAddressLists\", Boolean.parseBoolean(mailboxHideFromGAL), ProvisioningPlan.Operation.Set));\n                    accountRequest.add(newAttributeRequest(\"msExchRequireAuthToSendTo\", Boolean.parseBoolean(mailboxBlockIncomingEmail), ProvisioningPlan.Operation.Set));\n\n                    // Add attribute request for AuthOrig _IF_ we are blocking email receipt \n                    // note that we can not / should not use a == comparision operation as that actually works to determine if the objects are \n                    // the SAME object - NOT whether foe example the text values are the same.\n                    if (mailboxBlockIncomingEmail.equals(\"true\")) {\n                        accountRequest.add(newAttributeRequest(\"authOrig\", aDAcctNativeID, ProvisioningPlan.Operation.Set));\n                    } else {\n                        accountRequest.add(newAttributeRequest(\"authOrig\", \"\", ProvisioningPlan.Operation.Set));\n                    }\n                } else {\n                    // These are the NORMAL/DEFAULT disable case settings for email control attrubutes\n                    accountRequest.add(newAttributeRequest(\"msExchHideFromAddressLists\", false, ProvisioningPlan.Operation.Set));\n                    accountRequest.add(newAttributeRequest(\"msExchRequireAuthToSendTo\", false, ProvisioningPlan.Operation.Set));\n                    accountRequest.add(newAttributeRequest(\"authOrig\", aDAcctNativeID, ProvisioningPlan.Operation.Set));\n                }\n                \n\n                \n            } else if (op != null && AccountRequest.Operation.Disable.equals(op) && !suspendedLcs.equals(currentLcs)) {\n\n                String mailboxHideFromGAL = \"true\";\n                String mailboxBlockIncomingEmail = \"true\";\n\n                log.debug(\"Disable request for user with terminated LCS. Resetting attributes msExchHideFromAddressLists and msExchRequireAuthToSendTo\");\n\n                String aDAcctNativeID = accountRequest.getNativeIdentity();\n                \n                /**\n                 * Rakash leverages the happenstance that identity name and NativeID of source\n                 * SNOWReqParam account would be the same value (as configured).\n                 */\n                String SRPAcctNativeIdentity = identity.getName();\n\n                /** \n                  * Depending on the LCS change scenario for the identity in question when an AD account is disabled there may or \n                  * may not be a  SNOWReqParam account for the identity. IF there is one then we want to use the specified flag \n                  * settings in that record for mailbox behavior.\n                  */\n                if (SRPAcctNativeIdentity != null && idn.accountExistsByDisplayName(SNOWReqParams, SRPAcctNativeIdentity)) {\n                    log.debug(\"SNOWReqParams source record exists for identity\");\n\n                    /* gather values from SNOWReqParam */\n                    mailboxHideFromGAL = idn.getAccountAttribute(SNOWReqParams, SRPAcctNativeIdentity, \"mailboxHideFromGAL\").toString().toLowerCase();\n                    mailboxBlockIncomingEmail = idn.getAccountAttribute(SNOWReqParams, SRPAcctNativeIdentity, \"mailboxBlockIncomingEmail\").toString().toLowerCase();\n                    /* may wan to put some debug output here to show the values obtained */\n\n                    /* if values are empty then override to default value */\n                    if (mailboxHideFromGAL == null) {\n                        mailboxHideFromGAL = \"true\";\n                    }\n                    if (mailboxBlockIncomingEmail == null) {\n                        mailboxBlockIncomingEmail = \"true\";\n                    }\n                    /** 2024-04-08\n                     * Assigning the requestor email to extentionAttribute12 was causing failures possibly due to AD settings so we do not \n                     * use an AD attribute to pass that information to the script. Instead the script must do account api calls to obtain\n                     * the value for notifications.\n                     */\n                    accountRequest.add(newAttributeRequest(\"msExchHideFromAddressLists\", Boolean.parseBoolean(mailboxHideFromGAL), ProvisioningPlan.Operation.Set));\n                    accountRequest.add(newAttributeRequest(\"msExchRequireAuthToSendTo\", Boolean.parseBoolean(mailboxBlockIncomingEmail), ProvisioningPlan.Operation.Set));\n\n                    // Add attribute request for AuthOrig _IF_ we are blocking email receipt \n                    // note that we can not / should not use a == comparision operation as that actually works to determine if the objects are \n                    // the SAME object - NOT whether foe example the text values are the same.\n                    if (mailboxBlockIncomingEmail.equals(\"true\")) {\n                        accountRequest.add(newAttributeRequest(\"authOrig\", aDAcctNativeID, ProvisioningPlan.Operation.Set));\n                    } else {\n                        accountRequest.add(newAttributeRequest(\"authOrig\", \"\", ProvisioningPlan.Operation.Set));\n                    }\n                } else {\n                    // These are the NORMAL/DEFAULT disable case settings for email control attrubutes\n                    accountRequest.add(newAttributeRequest(\"msExchHideFromAddressLists\", true, ProvisioningPlan.Operation.Set));\n                    accountRequest.add(newAttributeRequest(\"msExchRequireAuthToSendTo\", true, ProvisioningPlan.Operation.Set));\n                    accountRequest.add(newAttributeRequest(\"authOrig\", aDAcctNativeID, ProvisioningPlan.Operation.Set));\n                }\n                \n\n                \n            } else if (op != null && AccountRequest.Operation.Modify.equals(op)) {\n                //check if there is a domain change\n                /**\n                 * 20240403 - note that there is a comflicting understanding that the exchange server builds the email address \n                 * seperately from whatever is assigned to the AD mail attribute by SailPoint or manually. TBC.\n                 */\n                AttributeRequest domainReq = accountRequest.getAttributeRequest(\"extensionAttribute11\");\n                if (domainReq != null) {\n                    String newDomain = (String) domainReq.getValue();\n                    String newEmailAddr = generateEmailAddress(firstname, lastname, newDomain);\n                    \n                    if (newEmailAddr != null && newEmailAddr != \"\") {\n                        accountRequest.add(newAttributeRequest(\"mail\", newEmailAddr, ProvisioningPlan.Operation.Set));\n                        accountRequest.add(newAttributeRequest(\"userPrincipalName\", newEmailAddr, ProvisioningPlan.Operation.Set));\n                    }\n\n                }\n            }\n        }\n    }\n    log.debug(\"IGM Plan update in AD  before Provisioning Rule is complete\");\n}\n  "
                },
                "attributes": {
                    "sourceVersion": "2025-07-29 07:22:25"
                },
                "id": "8d95d1e70b5d4281a9518d1513996692",
                "name": "Active Directory BeforeProvisioning",
                "created": "2023-01-26T23:26:00.392Z",
                "modified": "2025-07-29T07:22:26.693Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "936f266fbd984f9390130f35f411191d",
                "name": "NH AD BeforeProvisioning"
            },
            "object": {
                "description": "This rule will be used to update the provisioning plan before it is sent to the connector",
                "type": "BeforeProvisioning",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2025-06-20 18:49:08",
                    "script": "\nimport java.util.List;\nimport sailpoint.object.Application;\nimport sailpoint.object.Identity;\nimport sailpoint.object.ProvisioningPlan;\nimport sailpoint.object.ProvisioningPlan.AccountRequest;\nimport sailpoint.object.ProvisioningPlan.AttributeRequest;\nimport sailpoint.object.ProvisioningPlan.Operation;\nimport sailpoint.tools.Util;\n    \npublic AttributeRequest newAttributeRequest(String attributeName, Object attributeValue, ProvisioningPlan.Operation op) {\n\tAttributeRequest attributeRequest = new ProvisioningPlan.AttributeRequest();\n\n    attributeRequest.setName(attributeName);\n    attributeRequest.setOperation(op);\n    attributeRequest.setValue(attributeValue);\n\n    return attributeRequest;\n}\n\t\npublic String generateEmailAddress(String firstName, String lastName, String domain){\n\t\n\tString email = \"\";\n\n    if (Util.isNullOrEmpty(firstName) || Util.isNullOrEmpty(lastName) || Util.isNullOrEmpty(domain)) {\n        return null;\n    }\n   \t\t \n    String base = firstName + \".\" + lastName;\n    email = base + \"@\" + domain;\n    if (!isUnique(email, identity)) {\n        for (int count = 1; count < 100; count++) {\n            email = base + count + \"@\" + domain;\n            if (isUnique(email, identity)) {\n                break;\n            }\n        }\n    }\n\n    return email;\n\n}\n\n\n//This method checks uniqueness of generated email\npublic boolean isUnique(String email, Identity identity){\n    boolean isUnique = false;\n\n    //check uniqueness in AD\n    if (idn.isUniqueLDAPValue(identity.getName(), application.getName(), \"mail\", email)) {\n        isUnique = true;\n    }\n\n    return isUnique;\n}\n\n/**\n * Upated By Rakesh Kapoor 03/14/2024\n * Updated 03/19/2024\n * Updated 03/21/2024\n * 2024-04-03 Scott Walker      Re-org main and add comments to help diagnose failure to update AD attributes \n * 2024-04-04 Scott Walker      Remove extentionAttribute12 assignment to determine if this is the cause of attribute update failures\n * 2024-04-08 Scott Walker      Clean up debugging code and submit candidate final version for Immed susp/term enhancement.\n * Main Program Starts Here\n */\n\n// Give name of the source SNOWReqParams \nString SNOWReqParams = \"SNOWReqParams [source]\";\n\nif (plan != null) {\n    String currentLcs = \"\";\n    String deletedLcs = \"deleted\";\n    String firstname = \"\";\n    String lastname = \"\";\n    String truestring = \"true\";\n\t\n\t//new line Rahul\n    String userType = \"\";\n\n    Identity identity = plan.getIdentity();\n    if (identity != null) {\n        currentLcs = (String) identity.getAttribute(\"cloudLifecycleState\");\n        firstname = (String) identity.getAttribute(\"firstname\");\n        lastname = (String) identity.getAttribute(\"lastname\");\n\t\t\n\t\t//new line Rahul\n\t\tuserType = (String) identity.getAttribute(\"userType\");\n    }\n\n    // get the account request object/list\n    List accountRequests = plan.getAccountRequests();\n\n    if (accountRequests != null) {\n        for (AccountRequest accountRequest : accountRequests) {\n            AccountRequest.Operation op = accountRequest.getOperation();\n            log.debug(\"IGM AD Provisioning Rule: currentLcs state: \" + currentLcs);\n\n\n            if (op != null && AccountRequest.Operation.Enable.equals(op) && deletedLcs.equals(currentLcs)) {\n                /* SW - IGMs requirement is to actually delete active directory accounts when they are moved to a final phase of offboarding. \n                 * SailPoint IDN/ISC does not have a built in option for this in the account provisioning, it seems to have the view\n                 * that accounts would be disabled or perhaps moved to a seperate OU, but not deleted. Due to this we must [a] distinguish AD provisioning \n                 * settings between the initial offboarding state (terminated) and the final offboarding state (deleted) by configuring 'delete' to \n                 * look like it will enable the account again (i.e. to trigger the provisioning plan creation) but then [b] override the \n                 * accountRequest operation to Disable via this rule based on the LCS value of 'deleted'. \n                 */\n                log.debug(\"Enable request for user with deleted LCS. Updating account request with Delete operation\");\n                accountRequest.setOperation(AccountRequest.Operation.Delete);\n\t\t\t\t\n            } else if (op != null && AccountRequest.Operation.Enable.equals(op) && !deletedLcs.equals(currentLcs)) {\n\n                log.debug(\"Enable request for user without deleted LCS. Clearing attributes msExchHideFromAddressLists and msExchRequireAuthToSendTo\");\n\n                //Add attribute request for msExchHideFromAddressLists and msExchRequireAuthToSendTo\n                accountRequest.add(newAttributeRequest(\"msExchHideFromAddressLists\", false, ProvisioningPlan.Operation.Set));\n                accountRequest.add(newAttributeRequest(\"msExchRequireAuthToSendTo\", false, ProvisioningPlan.Operation.Set));\n\n                //Add attribute request for AuthOrig\n                accountRequest.add(newAttributeRequest(\"authOrig\", \"\", ProvisioningPlan.Operation.Set));\n\t\t\t\t\n\t\t\t\tif(userType.equalsIgnoreCase(\"SVC\") || userType.equalsIgnoreCase(\"BOT\") || userType.equalsIgnoreCase(\"TEST\") || userType.equalsIgnoreCase(\"PRA\") || userType.equalsIgnoreCase(\"PRF\"))\n\t\t\t\t{\n\t\t\t\t\taccountRequest.add(newAttributeRequest(\"extensionAttribute8\", \"revokeToDisableAccount\", ProvisioningPlan.Operation.Set));\n\t\t\t\t\t\n\t\t\t\t\t//new code\n\t\t\t\t\taccountRequest.add(newAttributeRequest(\"extensionAttribute9\", \"revokeToDeleteAccount\", ProvisioningPlan.Operation.Set));\n\t\t\t\t}\n\n            } else if (op != null && AccountRequest.Operation.Disable.equals(op)) {\n\n                String mailboxHideFromGAL = \"true\";\n                String mailboxBlockIncomingEmail = \"true\";\n\n                log.debug(\"Disable request for user with terminated LCS. Resetting attributes msExchHideFromAddressLists and msExchRequireAuthToSendTo\");\n\n                String aDAcctNativeID = accountRequest.getNativeIdentity();\n                \n                /**\n                 * Rakash leverages the happenstance that identity name and NativeID of source\n                 * SNOWReqParam account would be the same value (as configured).\n                 */\n                String SRPAcctNativeIdentity = identity.getName();\n\n                /** \n                  * Depending on the LCS change scenario for the identity in question when an AD account is disabled there may or \n                  * may not be a  SNOWReqParam account for the identity. IF there is one then we want to use the specified flag \n                  * settings in that record for mailbox behavior.\n                  */\n                if (SRPAcctNativeIdentity != null && idn.accountExistsByDisplayName(SNOWReqParams, SRPAcctNativeIdentity)) {\n                    log.debug(\"SNOWReqParams source record exists for identity\");\n\n                    /* gather values from SNOWReqParam */\n                    mailboxHideFromGAL = idn.getAccountAttribute(SNOWReqParams, SRPAcctNativeIdentity, \"mailboxHideFromGAL\").toString().toLowerCase();\n                    mailboxBlockIncomingEmail = idn.getAccountAttribute(SNOWReqParams, SRPAcctNativeIdentity, \"mailboxBlockIncomingEmail\").toString().toLowerCase();\n                    /* may wan to put some debug output here to show the values obtained */\n\n                    /* if values are empty then override to default value */\n                    if (mailboxHideFromGAL == null) {\n                        mailboxHideFromGAL = \"true\";\n                    }\n                    if (mailboxBlockIncomingEmail == null) {\n                        mailboxBlockIncomingEmail = \"true\";\n                    }\n                    /** 2024-04-08\n                     * Assigning the requestor email to extentionAttribute12 was causing failures possibly due to AD settings so we do not \n                     * use an AD attribute to pass that information to the script. Instead the script must do account api calls to obtain\n                     * the value for notifications.\n                     */\n                    accountRequest.add(newAttributeRequest(\"msExchHideFromAddressLists\", Boolean.parseBoolean(mailboxHideFromGAL), ProvisioningPlan.Operation.Set));\n                    accountRequest.add(newAttributeRequest(\"msExchRequireAuthToSendTo\", Boolean.parseBoolean(mailboxBlockIncomingEmail), ProvisioningPlan.Operation.Set));\n\n                    // Add attribute request for AuthOrig _IF_ we are blocking email receipt \n                    // note that we can not / should not use a == comparision operation as that actually works to determine if the objects are \n                    // the SAME object - NOT whether foe example the text values are the same.\n                    if (mailboxBlockIncomingEmail.equals(\"true\")) {\n                        accountRequest.add(newAttributeRequest(\"authOrig\", aDAcctNativeID, ProvisioningPlan.Operation.Set));\n                    } else {\n                        accountRequest.add(newAttributeRequest(\"authOrig\", \"\", ProvisioningPlan.Operation.Set));\n                    }\n                } else {\n                    // These are the NORMAL/DEFAULT disable case settings for email control attrubutes\n                    accountRequest.add(newAttributeRequest(\"msExchHideFromAddressLists\", true, ProvisioningPlan.Operation.Set));\n                    accountRequest.add(newAttributeRequest(\"msExchRequireAuthToSendTo\", true, ProvisioningPlan.Operation.Set));\n                    accountRequest.add(newAttributeRequest(\"authOrig\", aDAcctNativeID, ProvisioningPlan.Operation.Set));\n                }\n                \n\t\t\t\tif(userType.equalsIgnoreCase(\"SVC\") || userType.equalsIgnoreCase(\"BOT\") || userType.equalsIgnoreCase(\"TEST\") || userType.equalsIgnoreCase(\"PRA\") || userType.equalsIgnoreCase(\"PRF\"))\n\t\t\t\t{\n\t\t\t\t\taccountRequest.add(newAttributeRequest(\"extensionAttribute8\", \"revokeToDisableAccount\", ProvisioningPlan.Operation.Remove));\n\t\t\t\t}\n                \n            } else if (op != null && AccountRequest.Operation.Modify.equals(op)) {\n                //check if there is a domain change\n                /**\n                 * 20240403 - note that there is a comflicting understanding that the exchange server builds the email address \n                 * seperately from whatever is assigned to the AD mail attribute by SailPoint or manually. TBC.\n                 */\n                AttributeRequest domainReq = accountRequest.getAttributeRequest(\"extensionAttribute11\");\n                if (domainReq != null) {\n                    String newDomain = (String) domainReq.getValue();\n                    String newEmailAddr = generateEmailAddress(firstname, lastname, newDomain);\n                    \n                    if (newEmailAddr != null && newEmailAddr != \"\") {\n                        accountRequest.add(newAttributeRequest(\"mail\", newEmailAddr, ProvisioningPlan.Operation.Set));\n                        accountRequest.add(newAttributeRequest(\"userPrincipalName\", newEmailAddr, ProvisioningPlan.Operation.Set));\n                    }\n\n                }\t\t\t\t\n            }\n\t\t\t\n        }\n    }\n    log.debug(\"IGM Plan update in AD  before Provisioning Rule is complete\");\n} \n  "
                },
                "attributes": {
                    "sourceVersion": "2025-06-20 18:49:08"
                },
                "id": "936f266fbd984f9390130f35f411191d",
                "name": "NH AD BeforeProvisioning",
                "created": "2025-06-12T21:23:29.200Z",
                "modified": "2025-06-20T18:49:08.411Z"
            }
        },
        {
            "version": 1,
            "self": {
                "type": "RULE",
                "id": "f84dd5c28b8846edbb226c9e5bf9ab52",
                "name": "Non-Humans - Manager Correlation"
            },
            "object": {
                "description": "Finds a manager based on the manager's Lifecycle state attribute.",
                "type": "ManagerCorrelation",
                "signature": {
                    "input": [],
                    "output": null
                },
                "sourceCode": {
                    "version": "2024-04-12 14:59:23",
                    "script": "\n\nimport sailpoint.api.SailPointContext;\nimport sailpoint.object.Link;\nimport sailpoint.rule.Identity;\nimport sailpoint.server.IdnRuleUtil;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport sailpoint.object.Link;\nString managerSamAccountName = link.getAttribute(\"owner\");\nString accountLcs = link.getAttribute(\"lcs\");\nif(null != managerSamAccountName){\nList managers = idn.findIdentitiesBySearchableIdentityAttribute(\"samaccountname\", \"Equals\", managerSamAccountName, \"samaccountname\");\nif(null != managers && !\"deleted\".equalsIgnoreCase(accountLcs)){\nfor (Identity manager : managers) {\n    Map managerAttributes = manager.getAttributes();\n    String managerLCS = (String) managerAttributes.get(\"cloudLifecycleState\");\n    if(\"active\".equalsIgnoreCase(managerLCS)){\n        managerSamAccountName = managerSamAccountName;\n    } else {\n        String supermanId = manager.getManagerId();\n        Identity supermanIdentity = idn.getIdentityById(supermanId);\n        Map supermanAttributes = supermanIdentity.getAttributes();\n        managerSamAccountName = (String) supermanAttributes.get(\"samaccountname\");\n    }\n    break;\n}\n}\nMap returnMap = new HashMap();\nreturnMap.put(\"identityAttributeName\", \"samaccountname\");\nreturnMap.put(\"identityAttributeValue\", managerSamAccountName);\nreturn returnMap;\n}\n  "
                },
                "attributes": {
                    "sourceVersion": "2024-04-12 14:59:23"
                },
                "id": "f84dd5c28b8846edbb226c9e5bf9ab52",
                "name": "Non-Humans - Manager Correlation",
                "created": "2024-04-02T21:15:26.323Z",
                "modified": "2024-04-12T14:59:24.809Z"
            }
        }
    ]
}