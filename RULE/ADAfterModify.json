{
    "name": "ADAfterModify",
    "description": "Executes PowerShell commands on the IQService component after a source account is modified.",
    "type": "ConnectorAfterModify",
    "signature": {
        "input": [],
        "output": null
    },
    "source_code": {
        "version": "1.0",
        "script": "$logDate = Get-Date -UFormat  \"%Y%m%d\";\r\n$scriptPath = \"F:\\SailPoint\\Scripts\\AD_After_Modify\\After_Modify_Script.ps1\";\r\n$enableDebug = $true;\r\n\r\n#====================-------Helper functions-------====================\r\n# 2024-04-22 lotToFile updated to check for write error and sleep to retry to avoid write conflicts\r\n#====================-------Helper functions-------====================\r\nfunction logToFile([String] $info){\r\n    $(Get-Date -Format s) + \":  \" + $info | Out-File $logFile -Append;\r\n}\r\n\r\n#====================-------Get the request object-------====================\r\nTry {\r\n    Add-type -path C:\\SailPoint\\IQService\\Utils.dll;\r\n    $sReader = New-Object System.IO.StringReader([System.String]$env:Request);\r\n    $xmlReader = [System.xml.XmlTextReader]([sailpoint.utils.xml.XmlUtil]::getReader($sReader));\r\n    $requestObject = New-Object Sailpoint.Utils.objects.AccountRequest($xmlReader);\r\n    $requestAsString = $env:Request\r\n\r\n    #XML object\r\n    $xmlRequest = [xml]$requestAsString;\r\n\r\n    # It is assumed that there will only be one AccountRequest per call/execution of the rule. Otherwise we'd not handle each possible opreration\r\n    # and native identity values fully\r\n    $OpType = $xmlRequest.AccountRequest | ForEach-Object { $_.op };\r\n    $NativeIdent = $xmlRequest.AccountRequest | ForEach-Object { $_.nativeIdentity };\r\n    \r\n    $logFile = \"F:\\SailPoint\\Scripts\\AD_After_Modify\\Logs\\After_Modify_Rule_\" + $logDate + \".log\";\r\n\r\n    LogToFile(\"---------------------------------------------------------------------------------------------------------------\");\r\n    LogToFile(\"[START] IDN <Active Directory> Source - After Modify Rule - OpType: $OpType  NativeIdentity: $NativeIdent\");\r\n\r\n    if ($enableDebug) {\r\n        LogToFile(\"[DEBUG] Input Request String: $requestAsString\");\r\n    }\r\n\r\n    IF ($OpType -eq 'Disable') {\r\n        #$ExtAttr12 = $xmlRequest.AccountRequest.AttributeRequest | Where-Object Name -eq 'extentionAttribute12' | ForEach-Object { $_.value };\r\n        \r\n        # Find the element with the desired identifier (e.g. name value), then store the value from the desired attribute or sub-element\r\n        $targetElement = $xmlRequest.AccountRequest.AttributeRequest | Where-Object { $_.name -eq 'extentionAttribute12' }\r\n        $ExtAttr12 = $targetElement.value\r\n\r\n        $targetElement = $xmlRequest.AccountRequest.AttributeRequest | Where-Object { $_.name -eq 'msExchHideFromAddressLists' }\r\n        $MailHideFromGal = $targetElement.value.Boolean\r\n\r\n        $targetElement = $xmlRequest.AccountRequest.AttributeRequest | Where-Object { $_.name -eq 'msExchRequireAuthToSendTo' }\r\n        $MailRejectIncoming = $targetElement.value.Boolean\r\n\r\n        $targetElement = $xmlRequest.AccountRequest.AttributeRequest | Where-Object { $_.name -eq 'authOrig' }\r\n        $MailAuthOrig = $targetElement.value\r\n\r\n        # Note that although we don't need to do it so far it is possible there are mulitple matching elements and we might need to \r\n        # walk through them to get the value or values we want. e.g.\r\n        # $matchingProduct = $xml.group.product | Where-Object { $_.id.StartsWith($prefix) }\r\n        \r\n\r\n        LogToFile(\"[ACTION] OperationType: $OpType  - PERFORM CALL FOR IMMEDIATE AZURE SESSION REVOKE AND DISABLE\");\r\n        LogToFile(\"[INFO] MailHideFromGal: $MailHideFromGal\");\r\n        LogToFile(\"[INFO]   MailRejectInc: $MailRejectIncoming\");\r\n        LogToFile(\"[INFO]    MailAuthOrig: $MailAuthOrig\");\r\n        LogToFile(\"[INFO] --------------------------\");\r\n\r\n\r\n        #Escape double quotes to pass as a single string\r\n        $requestAsString = $requestAsString -replace '\"', '\\\"';\r\n\r\n        $Args = @\"\r\n-File $scriptPath -requestString \"$requestAsString\"\r\n\"@\r\n        #SailPoint times out after 60 seconds if the After Modify Rule does not finish execution, therefore Invoke-Expression has been replaced by Start-Process\r\n        #Invoke the After Modify script using start-process cmdlet. After invocation, this rule does not wait for the script invoked to finish execution\r\n        \r\n        logToFile(\"[INFO] Invoking $scriptPath\");\r\n        Start-Process powershell.exe -ArgumentList $Args;\r\n        logToFile(\"[INFO] $scriptPath invoked successfully\");\r\n\r\n    }\r\n    else {\r\n        LogToFile(\"[SKIP] OperationType: $OpType  - NO ADDTIONAL ACTIONS ADDED\");\r\n    }\r\n}\r\nCatch {\r\n    if (-not $logToFile) {\r\n        $logFile = \"F:\\SailPoint\\Scripts\\AD_After_Modify\\Logs\\ERROR_After_Modify_Rule_$logDate.log\"\r\n    }\r\n    $ErrorMessage = $_.Exception.Message \r\n    $ErrorItem = $_.Exception.ItemName\r\n    LogToFile(\"[ERROR] Error: Item = $ErrorItem -> Message = $ErrorMessage\")\r\n}\r\n\r\n\r\nLogToFile(\"[END] AD After modify completed execution\")"
    },
    "attributes": {
        "ObjectOrientedScript": "true",
        "extension": ".ps1",
        "sourceVersion": "1.0",
        "disabled": "false",
        "program": "powershell.exe",
        "timeout": "300"
    },
    "id": "b01235c3f95d41acbfdc15c33ea067c5",
    "created": "2025-06-19T16:41:20.901Z",
    "modified": "2025-06-19T16:41:42.358Z"
}